import pygame, math, datetime, randomimport timefrom pygame.locals import *from OpenGL.GL import *from OpenGL.GLU import *livingSpaceWidth = 100livingSpaceHeigth = 60livingSpaceDepth = 20creatureSize = 10livingSpace = []def initLivingSpace():	for x in range(livingSpaceWidth):		livingSpace.append([])		for y in range(livingSpaceHeigth):			livingSpace[x].append([])			for z in range(livingSpaceDepth):				if random.randint(0,1) == 1:					livingSpace[x][y].append(1000)				else:					livingSpace[x][y].append(0)def init():	glClearColor(1.0, 1.0, 1.0, 0.0)	glClearDepth(1.0)	# Tiefenpruefung aktivieren	glEnable(GL_DEPTH_TEST)	# Art der Pruefung festlegen	glDepthFunc(GL_LEQUAL)	# Transparenz aktivieren	glEnable(GL_BLEND)	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)	# Aktivierung der Beleuchtung	glEnable(GL_LIGHTING)	# Lichtquelle erzeugen	glLightfv(GL_LIGHT0, GL_AMBIENT, [0.6, 0.6, 0.6, 1.0])	glLightfv(GL_LIGHT0, GL_DIFFUSE, [0.4, 0.4, 0.4, 1.0])	glLightfv(GL_LIGHT0, GL_POSITION,			[(livingSpaceDepth * 20.0)/2.0,			(livingSpaceHeigth * 20.0)/2.0, -500.0, 1.0])	# Lichtquelle aktivieren	glEnable(GL_LIGHT0)	# Materialeigenschaften	glEnable(GL_COLOR_MATERIAL)	# Diffuses, ambientes Licht	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE)	# Automatische Korrektur der Normalen	glEnable(GL_NORMALIZE)	# Bestmoeglich rendern	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)def resize((width,heigth)):	if heigth == 0:		heigth = 1	glViewport(0, 0, width, heigth)	glMatrixMode(GL_PROJECTION)	glLoadIdentity()	glOrtho(-10.0, livingSpaceWidth * 10.0 + 10.0,		livingSpaceHeigth * 10.0 + 10.0, -10.0, -6.0, 0.0)	glMatrixMode(GL_MODELVIEW)	glLoadIdentity()def isAlive(x, y):	return livingSpace[x][y] == 1000def drawCube(x, y, z, cubeSize):	# Vordere Seitenflaeche	glNormal3f(0.0, 0.0, -1.0)	glVertex3f(x, y, z)	glVertex3f(cubeSize + x, y, z)	glVertex3f(cubeSize + x, cubeSize + y, z)	glVertex3f(x, cubeSize + y, z)	# Hintere Seitenflaeche	glNormal3f(0.0, 0.0, +1.0)	glVertex3f(x, y, z + cubeSize)	glVertex3f(cubeSize + x, y, z + cubeSize)	glVertex3f(cubeSize + x, cubeSize + y, z + cubeSize)	glVertex3f(x, cubeSize + y, z + cubeSize)	# Linke Seitenflaeche	glNormal3f(-1.0, 0.0, 0.0)	glVertex3f(x, y, z)	glVertex3f(x, cubeSize + y, z)	glVertex3f(x, cubeSize + y, z + cubeSize)	glVertex3f(x, y, z + cubeSize)	# Rechte Seitenflaeche	glNormal3f(+1.0, 0.0, 0.0)	glVertex3f(cubeSize + x, y, z)	glVertex3f(cubeSize + x, cubeSize + y, z)	glVertex3f(cubeSize + x, cubeSize + y, z + cubeSize)	glVertex3f(cubeSize + x, y, z + cubeSize)	# Obere Seitenflaeche	glNormal3f(0.0, +1.0, 0.0)	glVertex3f(x, cubeSize + y, z)	glVertex3f(cubeSize + x, cubeSize + y, z)	glVertex3f(cubeSize + x, cubeSize + y, z + cubeSize)	glVertex3f(x, cubeSize + y, z + cubeSize)	# Untere Seitenflaeche	glNormal3f(0.0, -1.0, 0.0)	glVertex3f(x, y, z)	glVertex3f(cubeSize + x, y, z)	glVertex3f(cubeSize + x, y, z + cubeSize)	glVertex3f(x, y, z + cubeSize)def draw():	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)	glBegin(GL_QUADS)	for column in range(livingSpaceWidth):		for row in range(livingSpaceHeigth):			for depth in range(livingSpaceDepth):				if livingSpace[column][row][depth] > 0:					healthStatus = float(livingSpace[column][row][depth]) / 1000.0					if depth % 2 == 0:						glColor4f(1.0, 0.0, 0.0, healthStatus)					elif depth % 3 == 0:						glColor4f(0.0, 1.0, 0.0, healthStatus)					else:						glColor4f(0.0, 0.0, 1.0, healthStatus)					x = column * 20.0					y = row * 20.0					z = depth * 20.0					drawCube(x, y, z, 15.0)	glEnd()def getNeighborCount(x, y):	count = 0	xpn = (x + 1) % livingSpaceWidth	ypn = (y + 1) % livingSpaceHeigth	count += isAlive(x, ypn)	count += isAlive(xpn, ypn)	count += isAlive(xpn, y)	count += isAlive(xpn, y - 1)	count += isAlive(x, y - 1)	count += isAlive(x - 1, y - 1)	count += isAlive(x - 1, y)	count += isAlive(x - 1, ypn - 1)	return countdef calculateNextGeneration():	neighborCount = []	for column in range(livingSpaceWidth):		neighborCount.append([])		for row in range(livingSpaceHeigth):			neighborCount[column].append(getNeighborCount(column, row))	for column in range(livingSpaceWidth):		for row in range(livingSpaceHeigth):			if 2 <= neighborCount[column][row] <= 3:				if neighborCount[column][row] == 3:					# Geburt eines Lebeswesens					livingSpace[column][row] = 1000			else:				# Langsames sterben eines Lebewesens				livingSpace[column][row] = livingSpace[column][row] / 1.1			if livingSpace[column][row] < 200:				livingSpace[column][row] = 0def main():	video_flags = OPENGL | HWSURFACE | DOUBLEBUF	screenSize = (livingSpaceWidth * creatureSize, livingSpaceHeigth * creatureSize)	pygame.init()	pygame.display.set_mode(screenSize, video_flags)	initLivingSpace()	resize(screenSize)	init()	frames = 0	ticks = pygame.time.get_ticks()	while True:		event = pygame.event.poll()		if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):			break		draw()		#calculateNextGeneration()		pygame.display.flip()		#time.sleep(0.1)if __name__ == '__main__':	main()